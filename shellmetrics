#!/bin/bash

test || eval "__() { :; }"

set -eu

VERSION=0.2.0

usage() {
cat<<HERE
Usage: shellmetrics [options] files...

  -s, --shell           The path of shell to use as parser [default: bash]
                          Supported shells: bash, mksh, yash, zsh
      --[no-]color      Enable / Disable color [default: enabled]
  -p, --pretty          Format pretty with wrapper function(s)
  -d, --debug           Display parsed data for debug instead of report
  -v, --version         Display the version
  -h, --help            You're looking at it
HERE
}

[ "${ZSH_VERSION:-}" ] && setopt shwordsplit

MARK="@SHELLMATRICS_LINENO@"
SP=$(printf ' \t') && TAB=${SP#?}

SHELL_VERSION='' INDENT="$TAB"
[ "${BASH_VERSION:-}" ] && SHELL_VERSION="bash $BASH_VERSION" INDENT="    "
[ "${ZSH_VERSION:-}" ] && SHELL_VERSION="zsh $ZSH_VERSION"
[ "${YASH_VERSION:-}" ] && SHELL_VERSION="yash $YASH_VERSION" INDENT="   "
case ${KSH_VERSION:-} in (*MIRBSD*) SHELL_VERSION="mksh $KSH_VERSION"; esac

putsn() {
  putsn() {
     printf '%s\n' "$1"
  }
  if [ "${KSH_VERSION:-}" ]; then
    putsn() {
      print -r -- "$1"
    }
  fi
  putsn "$@"
}

count() {
  max_indent=0 lines=0 comment_lines=0 blank_lines=0
  [ "$INDENT" = "$TAB" ] && indent_width=8 || indent_width=${#INDENT}
  while IFS= read -r line || [ "$line" ]; do
    is_comment_line "$line" && comment_lines=$((comment_lines + 1))
    is_blank_line "$line" && blank_lines=$((blank_lines + 1))
    line=${line%%[!$SP]*} lines=$((lines+1))
    max_indent=$(( (${#line}>max_indent) ? ${#line} : max_indent))
  done
  max_indent=$((max_indent / indent_width))
  eval "$1=$lines $2=$comment_lines $3=$blank_lines $4=$max_indent"
}

is_comment_line() {
  set -- "$1" "${1%%#*}"
  [ "$1" != "$2" ] && is_blank_line "$2"
}

is_blank_line() {
  case $1 in (*[!$SP]*) false; esac
}

repeat_string() {
  [ "$2" -gt 0 ] || return 0
  eval "$1=\"\${$1}$3\""
  repeat_string "$1" $(($2 - 1)) "$3"
}

array() {
  while [ $# -gt 0 ]; do
    eval "$1_array=0-0"
    shift
  done
}

array_is_empty() {
  eval "array=\$$1_array"
  eval "[ \$(($array)) -eq 0 ]"
}

push_array() {
  while [ $# -gt 0 ]; do
    eval "array=\${$1_array}"
    eval "$1_array_${array%-*}=\$$1"
    eval "$1_array_last=\$$1_array_${array%-*}"
    array=$((${array%-*}+1))-${array#*-}
    eval "$1_array=$array"
    shift
  done
}

pop_array() {
  while [ $# -gt 0 ]; do
    eval "array=\$$1_array"
    eval "[ \$(($array)) -eq 0 ]" && continue
    array=$((${array%-*}-1))-${array#*-}
    eval "$1=\$$1_array_${array%-*}"
    unset "$1_array_${array%-*}"
    if eval "[ \$(($array)) -eq 0 ]"; then
      unset "$1_array_last"
    else
      eval "$1_array_last=\$$1_array_$((${array%-*}-1))"
    fi
    eval "$1_array=$array"
    shift
  done
}

shift_array() {
  while [ $# -gt 0 ]; do
    eval "array=\$$1_array"
    eval "[ \$(($array)) -eq 0 ]" && continue
    eval "$1=\$$1_array_${array#*-}"
    unset "$1_array_${array#*-}"
    array=${array%-*}-$((${array#*-}+1))
    if eval "[ \$(($array)) -eq 0 ]"; then
      unset "$1_array_last"
    else
      eval "$1_array_last=\$$1_array_$((${array%-*}-1))"
    fi
    eval "$1_array=$array"
    shift
  done
}

peel() {
  i=0
  while [ "$i" -lt "$1" ] && i=$((i+1)); do
    IFS= read -r line
    [ "${line%"{"}" = "$line" ] && IFS= read -r line
  done
  set --
  while IFS= read -r line; do
    [ "$#" -eq "$i" ] && putsn "$1" && shift
    set -- "$@" "$line"
  done
}

pretty() {
  i=0
  while [ "$i" -lt "$1" ] && i=$((i+1)); do
    echo 'shellmetrics_wrapper() {'
  done
  sed "s/\([^\$'\"()]\)\( *()\)/\1_L$MARK\2/g" \
  | awk "{i++; gsub(/$MARK/,i); print}"
  while [ "$i" -gt 0 ] && i=$((i-1)); do
    echo '}'
  done
  echo "typeset -fp shellmetrics_wrapper"
}

process() {
  set -- "$(($1 + 1))"
  eval "$(pretty "$1")" | peel "$1" | parse "$1"
}

parse() {
  base='' eof='' indent='' nindent=0 pindent=0 ccn=1 lloc=0
  array indent func ccn lloc
  repeat_string base "$1" "$INDENT" && bindent=${#base}

  IFS= read -r next_line || eof=1
  indent=${next_line%%[!$SP]*} && next=${next_line#$indent}
  nindent=${#indent}

  until [ "$eof" ]; do
    mark="*  " current=$next current_line=$next_line cindent=$nindent
    IFS= read -r next_line || eof=1

    indent=${next_line%%[!$SP]*} && next=${next_line#$indent}
    nindent=${#indent}

    if [ "$cindent" -lt "$bindent" ]; then
      putsn "   |~  |${current_line#$base}"
      continue
    fi

    while :; do
      case $current in
        *\ "() {" | *"() {" | *" () " | *"()"            ) mark="*f "; break ;;
        "{ " | "{" | "}" | "} " | "};" | "} ;;" | "else") mark="   "; break ;;
        "(" | ")" | ") ;;" | "" | *" &&" | *" ||" | ";;") mark="   "; break ;;
        "then" | "("*")  ;;"                            ) mark="  c"; break ;;
        "("*")"*";;"                                    ) mark="* c"; break ;;
      esac

      if [ "$next" = "" ]; then
        case $current in
            *")"                                        ) mark="  c"; break ;;
          esac
      fi

      if [ "$cindent" -lt "$nindent" ]; then
        case $current in
          *" then"                                      ) mark="* c"; break ;;
          *" do"                                        ) mark="* l"; break ;;
          "do"                                          ) mark="  l"; break ;;
          *")"                                          ) mark="  c"; break ;;
          "("*")"*                                      ) mark="* c"; break ;;
        esac
      fi

      if [ "$cindent" -lt "$pindent" ]; then
        case $current in
          "fi"   | "fi "   | "fi;"   | "fi ;;"          ) mark="   "; break ;;
          "esac" | "esac " | "esac;" | "esac ;;"        ) mark="   "; break ;;
          "done" | "done " | "done;" | "done ;;"        ) mark="   "; break ;;
        esac
      fi

      break
    done
    pindent=$cindent

    indent_width=$((cindent-bindent))
    case $indent_width in
      ?) indent_width="  $indent_width" ;;
      ??) indent_width=" $indent_width" ;;
    esac
    putsn "$indent_width|$mark|${current_line#$base}"
  done
}

analyze() {
  ccn=1 lloc=0 func_array_last=0
  array indent func ccn lloc
  echo 0 0 "<begin>" "$1|${2:-0}:${3:-0}:${4:-0}"
  while IFS="|" read -r indent mark line; do
    case $mark in (*"~"*)
      continue
    esac

    case $line in (*"}" | *"};" | *"} "*)
      if [ "$indent" = "${indent_array_last:-none}" ]; then
        echo "$lloc" "$ccn" "$func_array_last" "$1"
        pop_array indent func ccn lloc
      fi
    esac

    case $mark in (*"*"*)
      lloc=$((lloc+1))
    esac

    case $mark in (*"c"* | *"l"*)
      ccn=$((ccn+1))
    esac

    case $mark in (*"f"*)
      func=${line%"()"*} && func=${func%" "} && func=${func##*[$SP]}
      lineno=${func##*_L} && func=${func%_L*}:$lineno
      push_array indent func ccn lloc
      ccn=1 lloc=0
    esac
  done
  echo "$lloc" "$ccn" "<main>" "$1"
  echo 0 0 "<end>" "$1|${2:-0}:${3:-0}:${4:-0}"
}

report() {
  echo "=============================================================================="
  echo "  LLOC  CCN  Location"
  echo "------------------------------------------------------------------------------"
  file_count=0 func_count=0
  array lloc_total ccn_total func_count file sloc_total
  while IFS=" " read -r lloc ccn func file; do
    if [ "$func" = "<begin>" ]; then
      lloc_total=0 ccn_total=0 func_count=0 sloc_total=0
      file_count=$((file_count+1))
      continue
    fi
    if [ "$func" = "<end>" ]; then
      file_metrics=${file##*"|"} && file=${file%"|"*}
      IFS=:$IFS && set -- $file_metrics && IFS=${IFS#?}
      sloc_total=$1
      push_array lloc_total ccn_total func_count file sloc_total
      continue
    fi
    lloc_total=$((lloc_total+lloc))
    ccn_total=$((ccn_total+ccn))
    func_count=$((func_count+1))
    printf '%6d %4d  %s %s\n' "$lloc" "$ccn" "$func" "$file"
  done
  echo "------------------------------------------------------------------------------"
  set -- "$file_count" "$func_count" "$SHELL_VERSION"
  printf " %d file(s), %d function(s) analyzed. [%s]\n" "$@"

  echo

  echo "=============================================================================="
  echo "  SLOC     LLOC      LLOC     CCN   Func   File"
  echo " total    total       avg     avg    cnt"
  echo "------------------------------------------------------------------------------"
  lloc_total_all=0 ccn_total_all=0 func_count_all=0 sloc_total_all=0
  until array_is_empty file; do
    shift_array lloc_total ccn_total func_count file sloc_total
    lloc_total_all=$((lloc_total_all+lloc_total))
    ccn_total_all=$((ccn_total_all+ccn_total))
    func_count_all=$((func_count_all+func_count))
    sloc_total_all=$((sloc_total_all+sloc_total))
    # shellcheck disable=SC2046
    set -- "$sloc_total" "$lloc_total" $(
      {
        echo "scale=2"
        echo "$lloc_total / $func_count"
        echo "$ccn_total / $func_count"
      } | bc
    ) "$func_count" "$file" &&:
    printf '%6d   %6d %9.2f %7.2f  %5d   %s\n' "$@"
  done
  echo "------------------------------------------------------------------------------"

  echo

  echo "=============================================================================="
  echo "  SLOC     LLOC      LLOC     CCN   Func   File"
  echo " total    total       avg     avg    cnt    cnt"
  echo "------------------------------------------------------------------------------"
  set --
  if [ "$file_count" -gt 0 ]; then
    # shellcheck disable=SC2046
    set -- "$sloc_total_all" "$lloc_total_all" $(
      {
        echo "scale=2"
        echo "$lloc_total_all / $func_count_all"
        echo "$ccn_total_all / $func_count_all"
      } | bc
    ) "$func_count_all" "$file_count" &&:
  fi
  printf '%6d   %6d %9.2f %7.2f  %5d  %5d\n' "$@"
  echo "------------------------------------------------------------------------------"
}

main() {
  if [ "$MODE" ]; then
    analyze() { echo "[$1]"; cat; echo; }
    report() { cat; }

    if [ "$MODE" = "pretty" ]; then
      parse() { cat; }
      peel() { cat; }
    fi
  fi

  for file in "$@"; do
    [ ! -f "$file" ] && error "'$file' is not a file." && continue
    lines=0 comment_lines=0 blank_lines=0 max_indent=0 filepath=$file
    count lines comment_lines blank_lines max_indent < "$file"
    process "$max_indent" < "$file" | {
      analyze "$filepath" "$lines" "$comment_lines" "$blank_lines"
    }
  done | report
}

error() {
  sleep 0
  if [ "$COLOR" ]; then
    printf '\033[2;31m%s\033[0m\n' "${*:-}" >&2
  else
    printf '%s\n' "${*:-}" >&2
  fi
}

abort() {
  error "$@"
  exit 1
}

unknown() { abort "Unrecognized option '$1'"; }
required() { [ $# -gt 1 ] || abort "Option '$1' requires an argument"; }
param() { eval "$1=\$$1\ \\\"\"\\\${$2}\"\\\""; }
params() { [ "$2" -ge "$3" ] || params_ "$@"; }
params_() { param "$1" "$2"; params "$1" $(($2 + 1)) "$3"; }

parse_options() {
  OPTIND=$(($# + 1))
  while [ $# -gt 0 ]; do
    case $1 in
      -s | --shell    ) required "$@" && shift; SH=$1 ;;
           --color    ) COLOR=1 ;;
           --no-color ) COLOR='' ;;
      -p | --pretty   ) MODE=pretty ;;
      -d | --debug    ) MODE=debug ;;
      -h | --help     ) usage; exit ;;
      -v | --version  ) echo "$VERSION"; exit ;;
      --) shift; params PARAMS $((OPTIND - $#)) $OPTIND; break ;;
      -?*) unknown "$@" ;;
      *) param PARAMS $((OPTIND - $#))
    esac
    shift
  done
}

SH=bash MODE='' PARAMS=''
[ -t 1 ] && COLOR=1 || COLOR=''

${__SOURCED__:+return}

parse_options "$@"
[ "$SH" = "-" ] || exec $SH "$0" "$@" --shell -
eval "set -- $PARAMS"

__ main __

[ "$SHELL_VERSION" ] || abort "Unsupported shell."

main "$@"
